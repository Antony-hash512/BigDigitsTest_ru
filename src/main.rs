mod dynamic_int;

use dynamic_int::DynamicInt;
use std::time::Instant;
use std::thread;
use std::sync::{Arc, mpsc};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::io::{self, Write};

fn main() {
    println!("üî¢ –ü–æ–∏—Å–∫ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º DynamicInt");
    println!("================================================");
    
    loop {
        println!("\nüìã –í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã:");
        println!("1. üß™ –¢–µ—Å—Ç –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª");
        println!("2. üîç –ü–æ–∏—Å–∫ –≤ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ (—Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)");
        println!("3. üöÄ –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª");
        println!("4. üîÑ –û–¥–Ω–æ–ø–æ—Ç–æ—á–Ω—ã–π –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –ø–æ–∏—Å–∫ (—Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)");
        println!("5. ‚ôæÔ∏è  –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ (—Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)");
        println!("6. üî¢ –¢–µ—Å—Ç –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª");
        println!("7. üîç –ü–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ");
        println!("8. üöÄ –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª");
        println!("9. ‚ôæÔ∏è  –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª");
        println!("10. üö™ –í—ã—Ö–æ–¥");
        println!("\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä (1-10): ");
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –≤–≤–æ–¥");
        
        match input.trim() {
            "1" => {
                test_known_perfect_numbers();
            }
            "2" => {
                println!("\nüìä –í–≤–µ–¥–∏—Ç–µ –¥–∏–∞–ø–∞–∑–æ–Ω –ø–æ–∏—Å–∫–∞:");
                
                print!("–ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ: ");
                io::stdout().flush().unwrap();
                let mut start_input = String::new();
                io::stdin().read_line(&mut start_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let start_num: i128 = start_input.trim().parse().unwrap_or(8129);
                
                print!("–ö–æ–Ω–µ—á–Ω–æ–µ —á–∏—Å–ª–æ: ");
                io::stdout().flush().unwrap();
                let mut end_input = String::new();
                io::stdin().read_line(&mut end_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let end_num: i128 = end_input.trim().parse().unwrap_or(50000);
                
                search_perfect_numbers_in_range(start_num, end_num);
            }
            "3" => {
                println!("\nüßµ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞:");
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —è–¥–µ—Ä
                let available_cores = thread::available_parallelism().map(|p| p.get()).unwrap_or(4);
                println!("üíª –î–æ—Å—Ç—É–ø–Ω–æ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —è–¥–µ—Ä: {}", available_cores);
                
                print!("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é {}): ", available_cores);
                io::stdout().flush().unwrap();
                let mut threads_input = String::new();
                io::stdin().read_line(&mut threads_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let num_threads = threads_input.trim().parse().unwrap_or(available_cores);
                
                print!("–ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2): ");
                io::stdout().flush().unwrap();
                let mut start_input = String::new();
                io::stdin().read_line(&mut start_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let start_num: i128 = start_input.trim().parse().unwrap_or(2);
                
                print!("–†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 100000): ");
                io::stdout().flush().unwrap();
                let mut chunk_input = String::new();
                io::stdin().read_line(&mut chunk_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let chunk_size: i128 = chunk_input.trim().parse().unwrap_or(100000);
                
                println!("\nüöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫...");
                find_perfect_numbers_multithreaded(num_threads, start_num, chunk_size);
            }
            "4" => {
                println!("\n‚ö†Ô∏è  –í–Ω–∏–º–∞–Ω–∏–µ! –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –ø–æ–∏—Å–∫ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–µ–Ω—å –¥–æ–ª–≥–æ!");
                print!("–í—ã —É–≤–µ—Ä–µ–Ω—ã? (y/N): ");
                io::stdout().flush().unwrap();
                let mut confirm = String::new();
                io::stdin().read_line(&mut confirm).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                
                if confirm.trim().to_lowercase() == "y" || confirm.trim().to_lowercase() == "yes" {
                    find_perfect_numbers();
                } else {
                    println!("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.");
                }
            }
            "5" => {
                println!("\n‚ö†Ô∏è  –í–Ω–∏–º–∞–Ω–∏–µ! –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–µ–Ω—å –¥–æ–ª–≥–æ!");
                print!("–í—ã —É–≤–µ—Ä–µ–Ω—ã? (y/N): ");
                io::stdout().flush().unwrap();
                let mut confirm = String::new();
                io::stdin().read_line(&mut confirm).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                
                if confirm.trim().to_lowercase() == "y" || confirm.trim().to_lowercase() == "yes" {
                    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
                    let available_cores = thread::available_parallelism().map(|p| p.get()).unwrap_or(4);
                    println!("üíª –î–æ—Å—Ç—É–ø–Ω–æ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —è–¥–µ—Ä: {}", available_cores);
                    
                    print!("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é {}): ", available_cores);
                    io::stdout().flush().unwrap();
                    let mut threads_input = String::new();
                    io::stdin().read_line(&mut threads_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                    let num_threads = threads_input.trim().parse().unwrap_or(available_cores);
                    
                    find_perfect_numbers_infinite_multithreaded(num_threads);
                } else {
                    println!("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.");
                }
            }
            "6" => {
                test_prime_numbers();
            }
            "7" => {
                println!("\nüìä –í–≤–µ–¥–∏—Ç–µ –¥–∏–∞–ø–∞–∑–æ–Ω –ø–æ–∏—Å–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª:");
                
                print!("–ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ: ");
                io::stdout().flush().unwrap();
                let mut start_input = String::new();
                io::stdin().read_line(&mut start_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let start_num: i128 = start_input.trim().parse().unwrap_or(2);
                
                print!("–ö–æ–Ω–µ—á–Ω–æ–µ —á–∏—Å–ª–æ: ");
                io::stdout().flush().unwrap();
                let mut end_input = String::new();
                io::stdin().read_line(&mut end_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let end_num: i128 = end_input.trim().parse().unwrap_or(100);
                
                search_primes_in_range(start_num, end_num);
            }
            "8" => {
                println!("\nüßµ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª:");
                
                let available_cores = thread::available_parallelism().map(|p| p.get()).unwrap_or(4);
                println!("üíª –î–æ—Å—Ç—É–ø–Ω–æ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —è–¥–µ—Ä: {}", available_cores);
                
                print!("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é {}): ", available_cores);
                io::stdout().flush().unwrap();
                let mut threads_input = String::new();
                io::stdin().read_line(&mut threads_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let num_threads = threads_input.trim().parse().unwrap_or(available_cores);
                
                print!("–ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2): ");
                io::stdout().flush().unwrap();
                let mut start_input = String::new();
                io::stdin().read_line(&mut start_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let start_num: i128 = start_input.trim().parse().unwrap_or(2);
                
                print!("–†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 100000): ");
                io::stdout().flush().unwrap();
                let mut chunk_input = String::new();
                io::stdin().read_line(&mut chunk_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                let chunk_size: i128 = chunk_input.trim().parse().unwrap_or(100000);
                
                println!("\nüöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª...");
                find_primes_multithreaded(num_threads, start_num, chunk_size);
            }
            "9" => {
                println!("\n‚ö†Ô∏è  –í–Ω–∏–º–∞–Ω–∏–µ! –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–µ–Ω—å –¥–æ–ª–≥–æ!");
                print!("–í—ã —É–≤–µ—Ä–µ–Ω—ã? (y/N): ");
                io::stdout().flush().unwrap();
                let mut confirm = String::new();
                io::stdin().read_line(&mut confirm).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                
                if confirm.trim().to_lowercase() == "y" || confirm.trim().to_lowercase() == "yes" {
                    let available_cores = thread::available_parallelism().map(|p| p.get()).unwrap_or(4);
                    println!("üíª –î–æ—Å—Ç—É–ø–Ω–æ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —è–¥–µ—Ä: {}", available_cores);
                    
                    print!("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é {}): ", available_cores);
                    io::stdout().flush().unwrap();
                    let mut threads_input = String::new();
                    io::stdin().read_line(&mut threads_input).expect("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è");
                    let num_threads = threads_input.trim().parse().unwrap_or(available_cores);
                    
                    find_primes_infinite_multithreaded(num_threads);
                } else {
                    println!("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.");
                }
            }
            "10" => {
                println!("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!");
                break;
            }
            _ => {
                println!("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
            }
        }
        
        println!("\n{}", "=".repeat(50));
    }
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª
fn find_perfect_numbers_multithreaded(num_threads: usize, start_num: i128, chunk_size: i128) {
    println!("üöÄ –ù–∞—á–∏–Ω–∞–µ–º –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª...");
    println!("   üßµ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   üìä –ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ: {}", start_num);
    println!("   üì¶ –†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫: {}", chunk_size);
    println!("   ‚ö†Ô∏è  –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n");
    
    let found_count = Arc::new(AtomicUsize::new(0));
    let checked_count = Arc::new(AtomicUsize::new(0));
    let (tx, rx) = mpsc::channel();
    let start_time = Instant::now();
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫–∏
    let mut handles = Vec::new();
    
    for thread_id in 0..num_threads {
        let tx_clone = tx.clone();
        let found_count_clone = Arc::clone(&found_count);
        let checked_count_clone = Arc::clone(&checked_count);
        let thread_start = start_num + (thread_id as i128 * chunk_size);
        let thread_end = thread_start + chunk_size;
        
        let handle = thread::spawn(move || {
            search_in_range_thread(
                thread_id,
                thread_start,
                thread_end,
                tx_clone,
                found_count_clone,
                checked_count_clone,
            );
        });
        
        handles.push(handle);
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    drop(tx);
    
    // –ö–ª–æ–Ω–∏—Ä—É–µ–º Arc –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –ø–æ—Ç–æ–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    let found_count_for_msg = Arc::clone(&found_count);
    let checked_count_for_msg = Arc::clone(&checked_count);
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let msg_handle = thread::spawn(move || {
        for result in rx {
            match result {
                ThreadMessage::PerfectFound { thread_id, number, type_name, check_time, total_checked } => {
                    let global_found = found_count_for_msg.fetch_add(1, Ordering::SeqCst) + 1;
                    let elapsed_total = start_time.elapsed();
                    
                    println!("üéâ –ù–ê–ô–î–ï–ù–û –°–û–í–ï–†–®–ï–ù–ù–û–ï –ß–ò–°–õ–û ‚Ññ{}!", global_found);
                    println!("   üìä –ß–∏—Å–ª–æ: {}", number);
                    println!("   üî¢ –¢–∏–ø: {}", type_name);
                    println!("   üßµ –ü–æ—Ç–æ–∫: #{}", thread_id);
                    println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∏—Å–ª–∞: {:.3?}", check_time);
                    println!("   ‚è∞ –û–±—â–µ–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {:.2?}", elapsed_total);
                    println!("   üìç –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}\n", total_checked);
                }
                ThreadMessage::Progress { thread_id, checked_in_thread } => {
                    if checked_in_thread % 50000 == 0 {
                        let total_checked = checked_count_for_msg.load(Ordering::SeqCst);
                        let elapsed = start_time.elapsed();
                        let speed = total_checked as f64 / elapsed.as_secs_f64();
                        println!("üîÑ –ü–æ—Ç–æ–∫ #{}: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ {} | –í—Å–µ–≥–æ: {} | –°–∫–æ—Ä–æ—Å—Ç—å: {:.0}/—Å–µ–∫", 
                            thread_id, checked_in_thread, total_checked, speed);
                    }
                }
            }
        }
    });
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ—Ç–æ–∫–æ–≤
    for handle in handles {
        handle.join().unwrap();
    }
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    msg_handle.join().unwrap();
    
    let total_time = start_time.elapsed();
    let total_checked_final = checked_count.load(Ordering::SeqCst);
    let total_found_final = found_count.load(Ordering::SeqCst);
    
    println!("\nüìä –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:");
    println!("   üßµ –ü–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   ‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª: {}", total_found_final);
    println!("   üìã –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ —á–∏—Å–µ–ª: {}", total_checked_final);
    println!("   ‚è±Ô∏è  –û–±—â–µ–µ –≤—Ä–µ–º—è: {:.2?}", total_time);
    println!("   ‚ö° –û–±—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: {:.0} —á–∏—Å–µ–ª/—Å–µ–∫", total_checked_final as f64 / total_time.as_secs_f64());
}

#[derive(Debug)]
enum ThreadMessage {
    PerfectFound {
        thread_id: usize,
        number: String,
        type_name: String,
        check_time: std::time::Duration,
        total_checked: usize,
    },
    Progress {
        thread_id: usize,
        checked_in_thread: usize,
    },
}

#[derive(Debug)]
enum PrimeThreadMessage {
    PrimeFound {
        thread_id: usize,
        number: String,
        type_name: String,
        check_time: std::time::Duration,
        total_checked: usize,
    },
    Progress {
        thread_id: usize,
        checked_in_thread: usize,
    },
}

fn search_in_range_thread(
    thread_id: usize,
    start: i128,
    end: i128,
    tx: mpsc::Sender<ThreadMessage>,
    _found_count: Arc<AtomicUsize>,
    checked_count: Arc<AtomicUsize>,
) {
    let mut current = DynamicInt::new(start);
    let one = DynamicInt::one();
    let end_num = DynamicInt::new(end);
    let mut checked_in_thread = 0;
    
    while current.lt(&end_num) {
        let check_start = Instant::now();
        
        if current.is_perfect() {
            let check_time = check_start.elapsed();
            let total_checked = checked_count.load(Ordering::SeqCst);
            
            let _ = tx.send(ThreadMessage::PerfectFound {
                thread_id,
                number: current.to_string_value(),
                type_name: current.get_type_name().to_string(),
                check_time,
                total_checked,
            });
        }
        
        checked_in_thread += 1;
        checked_count.fetch_add(1, Ordering::SeqCst);
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        if checked_in_thread % 10000 == 0 {
            let _ = tx.send(ThreadMessage::Progress {
                thread_id,
                checked_in_thread,
            });
        }
        
        current = current.add(&one);
    }
    
    println!("üèÅ –ü–æ—Ç–æ–∫ #{} –∑–∞–≤–µ—Ä—à–µ–Ω. –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ {} —á–∏—Å–µ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {}-{}", 
        thread_id, checked_in_thread, start, end);
}

fn test_known_perfect_numbers() {
    println!("üß™ –¢–µ—Å—Ç–∏—Ä—É–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞...\n");
    
    // –ü–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª: 6, 28, 496, 8128
    let test_numbers = vec![6, 28, 496, 8128];
    
    for num in test_numbers {
        let start_time = Instant::now();
        let dynamic_num = DynamicInt::new(num);
        let is_perfect = dynamic_num.is_perfect();
        let elapsed = start_time.elapsed();
        
        println!("–ß–∏—Å–ª–æ: {} | –°–æ–≤–µ—Ä—à–µ–Ω–Ω–æ–µ: {} | –¢–∏–ø: {} | –í—Ä–µ–º—è: {:.3?}",
            num, 
            if is_perfect { "‚úÖ" } else { "‚ùå" },
            dynamic_num.get_type_name(),
            elapsed
        );
    }
    
    println!("\nüîç –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–µ—Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª:");
    let non_perfect = vec![5, 7, 10, 12, 100, 1000];
    
    for num in non_perfect {
        let start_time = Instant::now();
        let dynamic_num = DynamicInt::new(num);
        let is_perfect = dynamic_num.is_perfect();
        let elapsed = start_time.elapsed();
        
        println!("–ß–∏—Å–ª–æ: {} | –°–æ–≤–µ—Ä—à–µ–Ω–Ω–æ–µ: {} | –¢–∏–ø: {} | –í—Ä–µ–º—è: {:.3?}",
            num, 
            if is_perfect { "‚úÖ" } else { "‚ùå" },
            dynamic_num.get_type_name(),
            elapsed
        );
    }
    
    println!("\nüéØ –†–µ–∑—É–ª—å—Ç–∞—Ç: –∞–ª–≥–æ—Ä–∏—Ç–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞!");
}

fn search_perfect_numbers_in_range(start: i128, end: i128) {
    println!("üîç –ò—â–µ–º —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç {} –¥–æ {}...\n", start, end);
    
    let mut current = DynamicInt::new(start);
    let one = DynamicInt::one();
    let end_num = DynamicInt::new(end);
    let mut found_count = 0;
    let mut checked_count = 0;
    let total_start_time = Instant::now();
    
    while current.lt(&end_num) {
        let start_time = Instant::now();
        
        if current.is_perfect() {
            let elapsed = start_time.elapsed();
            found_count += 1;
            
            println!("üéâ –ù–ê–ô–î–ï–ù–û –°–û–í–ï–†–®–ï–ù–ù–û–ï –ß–ò–°–õ–û ‚Ññ{}!", found_count);
            println!("   üìä –ß–∏—Å–ª–æ: {}", current.to_string_value());
            println!("   üî¢ –¢–∏–ø: {}", current.get_type_name());
            println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏: {:.3?}", elapsed);
            println!("   üìç –ü–æ–∑–∏—Ü–∏—è –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ: {}/{}\n", 
                current.to_string_value(), end);
        }
        
        checked_count += 1;
        
        // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —á–∏—Å–ª—É
        current = current.add(&one);
        
        // –î–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤—ã–≤–æ–¥–∏–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 5000 —á–∏—Å–µ–ª
        if checked_count % 5000 == 0 {
            let progress = (checked_count as f64 / (end - start) as f64) * 100.0;
            println!("üîÑ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {} —á–∏—Å–µ–ª ({:.1}%)", checked_count, progress);
        }
    }
    
    let total_elapsed = total_start_time.elapsed();
    println!("\nüìä –ò—Ç–æ–≥–∏ –ø–æ–∏—Å–∫–∞:");
    println!("   üî¢ –î–∏–∞–ø–∞–∑–æ–Ω: {} - {}", start, end);
    println!("   ‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª: {}", found_count);
    println!("   üìã –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}", checked_count);
    println!("   ‚è±Ô∏è  –û–±—â–µ–µ –≤—Ä–µ–º—è: {:.2?}", total_elapsed);
    println!("   ‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {:.0} —á–∏—Å–µ–ª/—Å–µ–∫", 
        checked_count as f64 / total_elapsed.as_secs_f64());
    
    if found_count == 0 {
        println!("   üí° –°–ª–µ–¥—É—é—â–µ–µ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ –ø–æ—Å–ª–µ 8128 = 33550336 (–æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ!)");
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ (–∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
fn find_perfect_numbers() {
    println!("üîç –ù–∞—á–∏–Ω–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –ø–æ–∏—Å–∫ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª...\n");
    println!("‚ö†Ô∏è  –í–Ω–∏–º–∞–Ω–∏–µ: —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏!");
    println!("   –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n");
    
    let mut current = DynamicInt::new(2); // –ù–∞—á–∏–Ω–∞–µ–º —Å 2
    let one = DynamicInt::one();
    let mut found_count = 0;
    let mut checked_count = 0;
    
    loop {
        let start_time = Instant::now();
        
        if current.is_perfect() {
            let elapsed = start_time.elapsed();
            found_count += 1;
            
            println!("üéâ –ù–ê–ô–î–ï–ù–û –°–û–í–ï–†–®–ï–ù–ù–û–ï –ß–ò–°–õ–û ‚Ññ{}!", found_count);
            println!("   üìä –ß–∏—Å–ª–æ: {}", current.to_string_value());
            println!("   üî¢ –¢–∏–ø: {}", current.get_type_name());
            println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏: {:.2?}", elapsed);
            println!("   üìç –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}\n", checked_count);
        }
        
        checked_count += 1;
        
        // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —á–∏—Å–ª—É
        current = current.add(&one);
        
        // –î–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤—ã–≤–æ–¥–∏–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10000 —á–∏—Å–µ–ª
        //if checked_count % 1000000 == 0 {
        //    println!("üîÑ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {} —á–∏—Å–µ–ª", checked_count);
        //}
    }
}

fn test1() {
    // –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    let num1 = DynamicInt::new(i128::MAX - 10);
    let num2 = DynamicInt::new(20);

    println!("num1: {}", num1.to_string_value());
    println!("num2: {}", num2.to_string_value());

    // –°–ª–æ–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ i128
    let sum = num1.add(&num2);
    println!("–°—É–º–º–∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è Big): {}", sum.to_string_value());
    if let DynamicInt::Big(_) = sum {
        println!("–°—É–º–º–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–ª–∞ BigInt!");
    }

    let small_sum = DynamicInt::new(5).add(&DynamicInt::new(10));
    println!("–ú–∞–ª–∞—è —Å—É–º–º–∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è Small): {}", small_sum.to_string_value());
    if let DynamicInt::Small(_) = small_sum {
        println!("–ú–∞–ª–∞—è —Å—É–º–º–∞ –æ—Å—Ç–∞–ª–∞—Å—å Small!");
    }

    // –£–º–Ω–æ–∂–µ–Ω–∏–µ
    let large_num_i128 = i128::MAX / 2;
    let mul1 = DynamicInt::new(large_num_i128);
    let mul2 = DynamicInt::new(3); // –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ 3 –ø–µ—Ä–µ–ø–æ–ª–Ω–∏—Ç i128::MAX

    println!("\nmul1: {}", mul1.to_string_value());
    println!("mul2: {}", mul2.to_string_value());

    let product = mul1.mul(&mul2);
    println!("–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (–æ–∂–∏–¥–∞–µ—Ç—Å—è Big): {}", product.to_string_value());
    if let DynamicInt::Big(_) = product {
        println!("–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–ª–æ BigInt!");
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
fn find_perfect_numbers_infinite_multithreaded(num_threads: usize) {
    println!("‚ôæÔ∏è  –ù–∞—á–∏–Ω–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª...");
    println!("   üßµ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   üì¶ –†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫: 1,000,000 —á–∏—Å–µ–ª");
    println!("   ‚ö†Ô∏è  –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n");
    
    let found_count = Arc::new(AtomicUsize::new(0));
    let checked_count = Arc::new(AtomicUsize::new(0));
    let current_start = Arc::new(AtomicUsize::new(2)); // –ù–∞—á–∏–Ω–∞–µ–º —Å 2
    let (tx, rx) = mpsc::channel();
    let start_time = Instant::now();
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫–∏
    let mut handles = Vec::new();
    
    for thread_id in 0..num_threads {
        let tx_clone = tx.clone();
        let found_count_clone = Arc::clone(&found_count);
        let checked_count_clone = Arc::clone(&checked_count);
        let current_start_clone = Arc::clone(&current_start);
        
        let handle = thread::spawn(move || {
            infinite_search_thread(
                thread_id,
                tx_clone,
                found_count_clone,
                checked_count_clone,
                current_start_clone,
            );
        });
        
        handles.push(handle);
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    drop(tx);
    
    // –ö–ª–æ–Ω–∏—Ä—É–µ–º Arc –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –ø–æ—Ç–æ–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    let found_count_for_msg = Arc::clone(&found_count);
    let checked_count_for_msg = Arc::clone(&checked_count);
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let msg_handle = thread::spawn(move || {
        for result in rx {
            match result {
                ThreadMessage::PerfectFound { thread_id, number, type_name, check_time, total_checked } => {
                    let global_found = found_count_for_msg.fetch_add(1, Ordering::SeqCst) + 1;
                    let elapsed_total = start_time.elapsed();
                    
                    println!("üéâ –ù–ê–ô–î–ï–ù–û –°–û–í–ï–†–®–ï–ù–ù–û–ï –ß–ò–°–õ–û ‚Ññ{}!", global_found);
                    println!("   üìä –ß–∏—Å–ª–æ: {}", number);
                    println!("   üî¢ –¢–∏–ø: {}", type_name);
                    println!("   üßµ –ü–æ—Ç–æ–∫: #{}", thread_id);
                    println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∏—Å–ª–∞: {:.3?}", check_time);
                    println!("   ‚è∞ –û–±—â–µ–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {:.2?}", elapsed_total);
                    println!("   üìç –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}\n", total_checked);
                }
                ThreadMessage::Progress { thread_id, checked_in_thread } => {
                    if checked_in_thread % 100000 == 0 {
                        let total_checked = checked_count_for_msg.load(Ordering::SeqCst);
                        let elapsed = start_time.elapsed();
                        let speed = total_checked as f64 / elapsed.as_secs_f64();
                        println!("üîÑ –ü–æ—Ç–æ–∫ #{}: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ {} | –í—Å–µ–≥–æ: {} | –°–∫–æ—Ä–æ—Å—Ç—å: {:.0}/—Å–µ–∫", 
                            thread_id, checked_in_thread, total_checked, speed);
                    }
                }
            }
        }
    });
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ—Ç–æ–∫–æ–≤ (–Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–ª—É—á–∏—Ç—Å—è –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–º –ø–æ–∏—Å–∫–µ)
    for handle in handles {
        handle.join().unwrap();
    }
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    msg_handle.join().unwrap();
}

fn infinite_search_thread(
    thread_id: usize,
    tx: mpsc::Sender<ThreadMessage>,
    _found_count: Arc<AtomicUsize>,
    checked_count: Arc<AtomicUsize>,
    current_start: Arc<AtomicUsize>,
) {
    let chunk_size = 1000000_i128; // 1 –º–∏–ª–ª–∏–æ–Ω —á–∏—Å–µ–ª –Ω–∞ –±–ª–æ–∫
    let mut checked_in_thread = 0;
    
    loop {
        // –ê—Ç–æ–º–∞—Ä–Ω–æ –ø–æ–ª—É—á–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
        let start = current_start.fetch_add(chunk_size as usize, Ordering::SeqCst) as i128;
        let end = start + chunk_size;
        
        println!("üßµ –ü–æ—Ç–æ–∫ #{} –Ω–∞—á–∏–Ω–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∏–∞–ø–∞–∑–æ–Ω–∞ {}-{}", thread_id, start, end);
        
        let mut current = DynamicInt::new(start);
        let one = DynamicInt::one();
        let end_num = DynamicInt::new(end);
        
        while current.lt(&end_num) {
            let check_start = Instant::now();
            
            if current.is_perfect() {
                let check_time = check_start.elapsed();
                let total_checked = checked_count.load(Ordering::SeqCst);
                
                let _ = tx.send(ThreadMessage::PerfectFound {
                    thread_id,
                    number: current.to_string_value(),
                    type_name: current.get_type_name().to_string(),
                    check_time,
                    total_checked,
                });
            }
            
            checked_in_thread += 1;
            checked_count.fetch_add(1, Ordering::SeqCst);
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            if checked_in_thread % 50000 == 0 {
                let _ = tx.send(ThreadMessage::Progress {
                    thread_id,
                    checked_in_thread,
                });
            }
            
            current = current.add(&one);
        }
        
        println!("üèÅ –ü–æ—Ç–æ–∫ #{} –∑–∞–≤–µ—Ä—à–∏–ª –¥–∏–∞–ø–∞–∑–æ–Ω {}-{}, –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ —Å–ª–µ–¥—É—é—â–µ–º—É", 
            thread_id, start, end);
    }
}

fn test_prime_numbers() {
    println!("üî¢ –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞...\n");
    
    // –ü–µ—Ä–≤—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞
    let test_primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
    
    println!("‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞:");
    for num in test_primes {
        let start_time = Instant::now();
        let dynamic_num = DynamicInt::new(num);
        let is_prime = dynamic_num.is_prime();
        let elapsed = start_time.elapsed();
        
        println!("–ß–∏—Å–ª–æ: {} | –ü—Ä–æ—Å—Ç–æ–µ: {} | –¢–∏–ø: {} | –í—Ä–µ–º—è: {:.3?}",
            num, 
            if is_prime { "‚úÖ" } else { "‚ùå" },
            dynamic_num.get_type_name(),
            elapsed
        );
    }
    
    println!("\n‚ùå –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–∞–≤–Ω—ã–µ —á–∏—Å–ª–∞:");
    let non_primes = vec![1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30];
    
    for num in non_primes {
        let start_time = Instant::now();
        let dynamic_num = DynamicInt::new(num);
        let is_prime = dynamic_num.is_prime();
        let elapsed = start_time.elapsed();
        
        println!("–ß–∏—Å–ª–æ: {} | –ü—Ä–æ—Å—Ç–æ–µ: {} | –¢–∏–ø: {} | –í—Ä–µ–º—è: {:.3?}",
            num, 
            if is_prime { "‚úÖ" } else { "‚ùå" },
            dynamic_num.get_type_name(),
            elapsed
        );
    }
    
    println!("\nüéØ –†–µ–∑—É–ª—å—Ç–∞—Ç: –∞–ª–≥–æ—Ä–∏—Ç–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞!");
}

fn search_primes_in_range(start: i128, end: i128) {
    println!("üîç –ò—â–µ–º –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç {} –¥–æ {}...\n", start, end);
    
    let mut current = DynamicInt::new(start);
    let one = DynamicInt::one();
    let end_num = DynamicInt::new(end);
    let mut found_count = 0;
    let mut checked_count = 0;
    let total_start_time = Instant::now();
    
    while current.lt(&end_num) {
        let start_time = Instant::now();
        
        if current.is_prime() {
            let elapsed = start_time.elapsed();
            found_count += 1;
            
            println!("üéâ –ù–ê–ô–î–ï–ù–û –ü–†–û–°–¢–û–ï –ß–ò–°–õ–û ‚Ññ{}: {}", found_count, current.to_string_value());
            if found_count <= 20 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–≤—ã—Ö 20
                println!("   üî¢ –¢–∏–ø: {} | ‚è±Ô∏è  –í—Ä–µ–º—è: {:.3?}", current.get_type_name(), elapsed);
            }
        }
        
        checked_count += 1;
        current = current.add(&one);
        
        // –î–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤—ã–≤–æ–¥–∏–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10000 —á–∏—Å–µ–ª
        if checked_count % 10000 == 0 {
            let progress = (checked_count as f64 / (end - start) as f64) * 100.0;
            println!("üîÑ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {} —á–∏—Å–µ–ª ({:.1}%)", checked_count, progress);
        }
    }
    
    let total_elapsed = total_start_time.elapsed();
    println!("\nüìä –ò—Ç–æ–≥–∏ –ø–æ–∏—Å–∫–∞:");
    println!("   üî¢ –î–∏–∞–ø–∞–∑–æ–Ω: {} - {}", start, end);
    println!("   ‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª: {}", found_count);
    println!("   üìã –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}", checked_count);
    println!("   ‚è±Ô∏è  –û–±—â–µ–µ –≤—Ä–µ–º—è: {:.2?}", total_elapsed);
    println!("   ‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {:.0} —á–∏—Å–µ–ª/—Å–µ–∫", 
        checked_count as f64 / total_elapsed.as_secs_f64());
}

fn find_primes_multithreaded(num_threads: usize, start_num: i128, chunk_size: i128) {
    println!("üöÄ –ù–∞—á–∏–Ω–∞–µ–º –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª...");
    println!("   üßµ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   üìä –ù–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ: {}", start_num);
    println!("   üì¶ –†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫: {}", chunk_size);
    println!("   ‚ö†Ô∏è  –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n");
    
    let found_count = Arc::new(AtomicUsize::new(0));
    let checked_count = Arc::new(AtomicUsize::new(0));
    let (tx, rx) = mpsc::channel();
    let start_time = Instant::now();
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫–∏
    let mut handles = Vec::new();
    
    for thread_id in 0..num_threads {
        let tx_clone = tx.clone();
        let found_count_clone = Arc::clone(&found_count);
        let checked_count_clone = Arc::clone(&checked_count);
        let thread_start = start_num + (thread_id as i128 * chunk_size);
        let thread_end = thread_start + chunk_size;
        
        let handle = thread::spawn(move || {
            search_primes_in_range_thread(
                thread_id,
                thread_start,
                thread_end,
                tx_clone,
                found_count_clone,
                checked_count_clone,
            );
        });
        
        handles.push(handle);
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    drop(tx);
    
    // –ö–ª–æ–Ω–∏—Ä—É–µ–º Arc –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –ø–æ—Ç–æ–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    let found_count_for_msg = Arc::clone(&found_count);
    let checked_count_for_msg = Arc::clone(&checked_count);
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let msg_handle = thread::spawn(move || {
        for result in rx {
            match result {
                PrimeThreadMessage::PrimeFound { thread_id, number, type_name, check_time, total_checked } => {
                    let global_found = found_count_for_msg.fetch_add(1, Ordering::SeqCst) + 1;
                    let elapsed_total = start_time.elapsed();
                    
                    println!("üéâ –ù–ê–ô–î–ï–ù–û –ü–†–û–°–¢–û–ï –ß–ò–°–õ–û ‚Ññ{}!", global_found);
                    println!("   üìä –ß–∏—Å–ª–æ: {}", number);
                    println!("   üî¢ –¢–∏–ø: {}", type_name);
                    println!("   üßµ –ü–æ—Ç–æ–∫: #{}", thread_id);
                    println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∏—Å–ª–∞: {:.3?}", check_time);
                    println!("   ‚è∞ –û–±—â–µ–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {:.2?}", elapsed_total);
                    println!("   üìç –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}\n", total_checked);
                }
                PrimeThreadMessage::Progress { thread_id, checked_in_thread } => {
                    if checked_in_thread % 50000 == 0 {
                        let total_checked = checked_count_for_msg.load(Ordering::SeqCst);
                        let total_found = found_count_for_msg.load(Ordering::SeqCst);
                        let elapsed = start_time.elapsed();
                        let speed = total_checked as f64 / elapsed.as_secs_f64();
                        println!("üîÑ –ü–æ—Ç–æ–∫ #{}: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ {} | –í—Å–µ–≥–æ: {} | –ù–∞–π–¥–µ–Ω–æ: {} | –°–∫–æ—Ä–æ—Å—Ç—å: {:.0}/—Å–µ–∫", 
                            thread_id, checked_in_thread, total_checked, total_found, speed);
                    }
                }
            }
        }
    });
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ—Ç–æ–∫–æ–≤
    for handle in handles {
        handle.join().unwrap();
    }
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    msg_handle.join().unwrap();
    
    let total_time = start_time.elapsed();
    let total_checked_final = checked_count.load(Ordering::SeqCst);
    let total_found_final = found_count.load(Ordering::SeqCst);
    
    println!("\nüìä –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:");
    println!("   üßµ –ü–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   ‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª: {}", total_found_final);
    println!("   üìã –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ —á–∏—Å–µ–ª: {}", total_checked_final);
    println!("   ‚è±Ô∏è  –û–±—â–µ–µ –≤—Ä–µ–º—è: {:.2?}", total_time);
    println!("   ‚ö° –û–±—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: {:.0} —á–∏—Å–µ–ª/—Å–µ–∫", total_checked_final as f64 / total_time.as_secs_f64());
}

fn search_primes_in_range_thread(
    thread_id: usize,
    start: i128,
    end: i128,
    tx: mpsc::Sender<PrimeThreadMessage>,
    _found_count: Arc<AtomicUsize>,
    checked_count: Arc<AtomicUsize>,
) {
    let mut current = DynamicInt::new(start);
    let one = DynamicInt::one();
    let end_num = DynamicInt::new(end);
    let mut checked_in_thread = 0;
    
    while current.lt(&end_num) {
        let check_start = Instant::now();
        
        if current.is_prime() {
            let check_time = check_start.elapsed();
            let total_checked = checked_count.load(Ordering::SeqCst);
            
            let _ = tx.send(PrimeThreadMessage::PrimeFound {
                thread_id,
                number: current.to_string_value(),
                type_name: current.get_type_name().to_string(),
                check_time,
                total_checked,
            });
        }
        
        checked_in_thread += 1;
        checked_count.fetch_add(1, Ordering::SeqCst);
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        if checked_in_thread % 10000 == 0 {
            let _ = tx.send(PrimeThreadMessage::Progress {
                thread_id,
                checked_in_thread,
            });
        }
        
        current = current.add(&one);
    }
    
    println!("üèÅ –ü–æ—Ç–æ–∫ #{} –∑–∞–≤–µ—Ä—à–µ–Ω. –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ {} —á–∏—Å–µ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {}-{}", 
        thread_id, checked_in_thread, start, end);
}

fn find_primes_infinite_multithreaded(num_threads: usize) {
    println!("‚ôæÔ∏è  –ù–∞—á–∏–Ω–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª...");
    println!("   üßµ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤: {}", num_threads);
    println!("   üì¶ –†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ –Ω–∞ –ø–æ—Ç–æ–∫: 1,000,000 —á–∏—Å–µ–ª");
    println!("   ‚ö†Ô∏è  –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n");
    
    let found_count = Arc::new(AtomicUsize::new(0));
    let checked_count = Arc::new(AtomicUsize::new(0));
    let current_start = Arc::new(AtomicUsize::new(2)); // –ù–∞—á–∏–Ω–∞–µ–º —Å 2
    let (tx, rx) = mpsc::channel();
    let start_time = Instant::now();
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫–∏
    let mut handles = Vec::new();
    
    for thread_id in 0..num_threads {
        let tx_clone = tx.clone();
        let found_count_clone = Arc::clone(&found_count);
        let checked_count_clone = Arc::clone(&checked_count);
        let current_start_clone = Arc::clone(&current_start);
        
        let handle = thread::spawn(move || {
            infinite_search_primes_thread(
                thread_id,
                tx_clone,
                found_count_clone,
                checked_count_clone,
                current_start_clone,
            );
        });
        
        handles.push(handle);
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    drop(tx);
    
    // –ö–ª–æ–Ω–∏—Ä—É–µ–º Arc –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –ø–æ—Ç–æ–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    let found_count_for_msg = Arc::clone(&found_count);
    let checked_count_for_msg = Arc::clone(&checked_count);
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let msg_handle = thread::spawn(move || {
        for result in rx {
            match result {
                PrimeThreadMessage::PrimeFound { thread_id, number, type_name, check_time, total_checked } => {
                    let global_found = found_count_for_msg.fetch_add(1, Ordering::SeqCst) + 1;
                    let elapsed_total = start_time.elapsed();
                    
                    println!("üéâ –ù–ê–ô–î–ï–ù–û –ü–†–û–°–¢–û–ï –ß–ò–°–õ–û ‚Ññ{}!", global_found);
                    println!("   üìä –ß–∏—Å–ª–æ: {}", number);
                    println!("   üî¢ –¢–∏–ø: {}", type_name);
                    println!("   üßµ –ü–æ—Ç–æ–∫: #{}", thread_id);
                    println!("   ‚è±Ô∏è  –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∏—Å–ª–∞: {:.3?}", check_time);
                    println!("   ‚è∞ –û–±—â–µ–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {:.2?}", elapsed_total);
                    println!("   üìç –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ: {}\n", total_checked);
                }
                PrimeThreadMessage::Progress { thread_id, checked_in_thread } => {
                    if checked_in_thread % 100000 == 0 {
                        let total_checked = checked_count_for_msg.load(Ordering::SeqCst);
                        let total_found = found_count_for_msg.load(Ordering::SeqCst);
                        let elapsed = start_time.elapsed();
                        let speed = total_checked as f64 / elapsed.as_secs_f64();
                        println!("üîÑ –ü–æ—Ç–æ–∫ #{}: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ {} | –í—Å–µ–≥–æ: {} | –ù–∞–π–¥–µ–Ω–æ: {} | –°–∫–æ—Ä–æ—Å—Ç—å: {:.0}/—Å–µ–∫", 
                            thread_id, checked_in_thread, total_checked, total_found, speed);
                    }
                }
            }
        }
    });
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ—Ç–æ–∫–æ–≤ (–Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–ª—É—á–∏—Ç—Å—è –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–º –ø–æ–∏—Å–∫–µ)
    for handle in handles {
        handle.join().unwrap();
    }
    
    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    msg_handle.join().unwrap();
}

fn infinite_search_primes_thread(
    thread_id: usize,
    tx: mpsc::Sender<PrimeThreadMessage>,
    _found_count: Arc<AtomicUsize>,
    checked_count: Arc<AtomicUsize>,
    current_start: Arc<AtomicUsize>,
) {
    let chunk_size = 1000000_i128; // 1 –º–∏–ª–ª–∏–æ–Ω —á–∏—Å–µ–ª –Ω–∞ –±–ª–æ–∫
    let mut checked_in_thread = 0;
    
    loop {
        // –ê—Ç–æ–º–∞—Ä–Ω–æ –ø–æ–ª—É—á–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
        let start = current_start.fetch_add(chunk_size as usize, Ordering::SeqCst) as i128;
        let end = start + chunk_size;
        
        println!("üßµ –ü–æ—Ç–æ–∫ #{} –Ω–∞—á–∏–Ω–∞–µ—Ç –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {}-{}", thread_id, start, end);
        
        let mut current = DynamicInt::new(start);
        let one = DynamicInt::one();
        let end_num = DynamicInt::new(end);
        
        while current.lt(&end_num) {
            let check_start = Instant::now();
            
            if current.is_prime() {
                let check_time = check_start.elapsed();
                let total_checked = checked_count.load(Ordering::SeqCst);
                
                let _ = tx.send(PrimeThreadMessage::PrimeFound {
                    thread_id,
                    number: current.to_string_value(),
                    type_name: current.get_type_name().to_string(),
                    check_time,
                    total_checked,
                });
            }
            
            checked_in_thread += 1;
            checked_count.fetch_add(1, Ordering::SeqCst);
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            if checked_in_thread % 50000 == 0 {
                let _ = tx.send(PrimeThreadMessage::Progress {
                    thread_id,
                    checked_in_thread,
                });
            }
            
            current = current.add(&one);
        }
        
        println!("üèÅ –ü–æ—Ç–æ–∫ #{} –∑–∞–≤–µ—Ä—à–∏–ª –¥–∏–∞–ø–∞–∑–æ–Ω {}-{}, –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ —Å–ª–µ–¥—É—é—â–µ–º—É", 
            thread_id, start, end);
    }
}
